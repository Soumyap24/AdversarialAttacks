# -*- coding: utf-8 -*-
"""Coloured_image_attack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hp6wfz357pV6sMK5r2jqLpYunXqrYaFz
"""



import numpy as np
import tensorflow as tf
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.utils import to_categorical
import matplotlib.pyplot as plt

# Load and preprocess the data
(x_train, y_train), (x_test, y_test) = cifar10.load_data()
x_train = x_train[:10000].astype('float32') / 255.0  # Use a subset for faster training
y_train = to_categorical(y_train[:10000], 10)
x_test = x_test.astype('float32') / 255.0
y_test = to_categorical(y_test, 10)

# Define the CNN model
model = Sequential([
    Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(32, 32, 3)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(64, kernel_size=(3, 3), activation='relu'),
    MaxPooling2D(pool_size=(2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=2, batch_size=200)  # Reduce epochs for faster training

# Function to add noise to specific pixels
def perturb_pixels(image, pixel_indices, noise_level):
    perturbed_image = np.copy(image)
    for idx in pixel_indices:
        x, y, r,g,b = idx
          # Ensure we do not go out of bounds
        perturbed_image[x, y, 0] = r*1e-2
        perturbed_image[x, y, 1] = g*1e-2
        perturbed_image[x, y, 2] = b*1e-2
    perturbed_image = np.clip(perturbed_image, 0.0, 1.0)
    return perturbed_image



# Select a single image from the test set
single_image = x_test[998]
single_image_label = y_test[998]
single_image_expanded = np.expand_dims(single_image, axis=0)
print(f'Single image label: {single_image_label}')

# Original prediction
original_prediction = np.argmax(model.predict(single_image_expanded))
print(f'Original prediction: {original_prediction}')
print(f' prediction: {model.predict(single_image_expanded)}')

# Visualize original image
plt.figure(figsize=(10, 10))
plt.subplot(3, 3, 1)
plt.title('Original Image')
plt.imshow(single_image)
plt.axis('off')
image_expanded=np.expand_dims(single_image, axis=0)
oz_prob = model.predict(image_expanded)
print(f'Oz image prediction: {oz_prob[0][np.argmax(single_image_label)] * 100:.2f}%')



perturbed_images = []

def fun(image, pixels, noise_level):
    perturbed_image = perturb_pixels(single_image, pixels, noise_level)
    perturbed_images.append(perturbed_image)
    perturbed_image_expanded = np.expand_dims(perturbed_image, axis=0)
    prediction = np.argmax(model.predict(perturbed_image_expanded))
    prob = model.predict(perturbed_image_expanded)
    print(f'Perturbed image prediction: {prediction}')
    max_value = np.max(prob)

    # # Visualize original image
    # plt.figure(figsize=(10, 10))
    # plt.subplot(3, 3, 1)
    # plt.title('Original Image')
    # plt.imshow(perturbed_image)
    # plt.axis('off')


    if prob[0][3] < max_value:
        print("misclassify")



    return prob[0][3] *100



# BAS algorithm
def bas(image, num_pixels_to_perturb, noise_level, n):
    # Parameter setup
    d0 =0.1
    d1 = 5
    d = d1
    eta_d = 0.99  # Slow reduction of the antenna distance

    l0 = 0.1
    l1 = 0.5
    l = l1
    eta_l = 0.98  # Slow reduction of the random walk

    step = 5

    eta_step = 0.98  # Slow reduction of the step size

    x0 = [(np.random.randint(0, 32), np.random.randint(0, 32), np.random.randint(0, 3), np.random.randint(0, 100), np.random.randint(0, 100)) for _ in range(num_pixels_to_perturb)]
    # x0 = [(np.random.randint(0, 32), np.random.randint(0, 32), np.random.randint(0, 3)) for _ in range(num_pixels_to_perturb)]
    # x0 =[(4, 28, 0), (9, 18, 0)]
    # x0= [(19, 31 , 0 ),( 3, 16,  0)]
    # x0= [(4, 17, 2), (9, 17, 2)]
    # x0=[(16, 20, 2), (5, 19, 2)]
    # x0=[[16 20  2][ 5 19  2]]





    # x0=[(9, 0, 1), (2, 10, 1), (5, 5, 1), (15, 11, 1), (24, 2, 1)]

    # x0=[(7, 5, 1), (9, 10, 0), (12, 3, 0), (26, 23, 2), (25, 16, 0)]
    # x0=[(15, 15, 1), (21, 15, 0), (11, 18, 0), (14, 3, 0), (11, 19, 0)]

    # x0=[(13, 7, 2), (6, 4, 2), (1, 1, 2), (14, 6, 2), (18, 27, 2)]
    # x0=[(6, 13, 1), (16, 10, 1), (6, 5, 1), (14, 0, 1), (5, 5, 1)]
    # x0=[(6, 3, 1), (2, 4, 1), (6, 5, 1), (10, 2, 1), (22, 1, 1)]
    # x0= [(16, 13, 2), (10, 7, 2), (3, 0, 2), (22, 0, 2), (14, 20, 2)]


#   #  [[ 0  3 34  1 32]
#  [17 10  2  8  1]
#  [24  0  6  7 31]
#  [23  7  3 82 22]
#  [14 25  0 30  0]]










    x = np.array(x0)
    xbest = x0
    fbest = fun(image, xbest, noise_level)
    fbest_store = [fbest]
    x_store = np.hstack([[0], x[:, 0], x[:, 1], [fbest]])
    print(f"0: xbest = {xbest}, fbest = {fbest}")

    # Iteration
    for i in range(1, n + 1):
        dir = np.random.randn(num_pixels_to_perturb, 5)
        dir = dir / (np.linalg.norm(dir, axis=1, keepdims=True) + np.finfo(float).eps)
        xleft = np.clip(x + dir * d, 0, 100).astype(int)
        xleft[:, 0] =  np.clip(xleft[:, 0], 0, 31)
        xleft[:, 1] =  np.clip(xleft[:, 1], 0, 31)
        print(xleft)
        fleft = fun(image, [tuple(coord) for coord in xleft], noise_level)
        xright = np.clip(x - dir * d, 0, 100).astype(int)
        xright[:, 0] = np.clip(xright[:, 0], 0, 31)
        xright[:, 1] = np.clip(xright[:, 1], 0, 31)
        print(xright)
        fright = fun(image, [tuple(coord) for coord in xright], noise_level)
        w = l * np.random.randn(num_pixels_to_perturb, 5)
        x = np.clip(x - step * dir * np.sign(fleft - fright) + w, 0, 100).astype(int)
        x[:, 0] = np.clip(x[:, 0], 0, 31)
        x[:, 1] = np.clip(x[:, 1], 0, 31)
        # x[:, 2] = np.random.randint(0, 3)
        print(x)
        # x[:, 2] = np.random.randint(0, 3)
        f = fun(image, [tuple(coord) for coord in x], noise_level)

        if f < fbest:
            xbest = x
            fbest = f

        if fright == 0 or fleft == 0 or f == 0:
            fbest = 0
        print(f"{i}: fbest = {fbest}")

        d = d * eta_d + d0
        l = l * eta_l + l0
        step = step * eta_step

    print(f"{i}: x0 = {x0}")
    print(f"{i}: xbest = {xbest}")

# Run the BAS algorithm
bas(single_image, 5,1, 100)

bas(single_image,2,1,1)